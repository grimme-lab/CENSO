"""
module for the calculation of shielding and coupling constants 
"""

import os
import shutil
import sys
import json
from random import normalvariate
from multiprocessing import JoinableQueue as Queue
from .cfg import PLENGTH, DIGILEN, AU2KCAL, WARNLEN, CODING, NmrRef, qm_prepinfo
from .parallel import run_in_parallel
from .orca_job import OrcaJob
from .tm_job import TmJob
from .utilities import (
    calc_boltzmannweights,
    printout,
    print_block,
    new_folders,
    last_folders,
    print,
    print_errors,
    calc_std_dev,
    ensemble2coord,
)


def read_chemeq(path):
    """read chemeq from anmr_nucinfo"""
    with open(path, "r") as inp:
        data = inp.readlines()
    nat = int(data[0].split()[0])
    tmpeq = {}
    for i in range(1, nat * 2 + 1):
        if i % 2 != 0:
            nextatom = int(data[i].split()[0])
        elif i % 2 == 0:
            equalatoms = [int(x) for x in data[i].split()]
            tmpeq[nextatom] = sorted(equalatoms)
    return tmpeq


def read_exp_ref(path):
    """read experimental reference shifts"""
    with open(os.path.join(path, ".ref"), "r") as inp:
        data = inp.readlines()
    expref = {}
    for line in data[1:]:
        if line not in ["\n", "\r\n"]:
            try:
                expref[int(line.split()[0])] = float(line.split()[1])
            except ValueError:
                pass
    return expref


def get_atom(path):
    """read coord"""
    with open(os.path.join(path, "coord"), "r") as inp:
        data = inp.readlines()
    element = {}
    i = 1
    for line in data[1:]:
        if "$" in line:  # stop at $end ...
            break
        element[i] = str(line.split()[3].lower())
        i += 1
    return element


def average_shieldings(config, calculate, element_ref_shield, energy, solv, rrho):
    """
    Read chemical equivalence and Boltzmann average the calculated shielding constants
    """
    path_anmr_nucinfo = os.path.join(config.cwd, "anmr_nucinfo")
    if not os.path.isfile(path_anmr_nucinfo):
        print(f"File anmr_nucinfo (generated by CREST) is not present!")
        return
    print("\nAveraged shielding constants:")
    chemeq = read_chemeq(path_anmr_nucinfo)
    averaged = {}
    element = {}
    sigma_std_dev = {}
    sigma_std_dev_const = {}
    for i in range(1, config.nat + 1):
        sigma_std_dev[i] = []
        sigma_std_dev_const[i] = []

    for conf in calculate:
        # get averaged shielding constants
        if not element:
            element = get_atom(
                os.path.normpath(os.path.join(config.cwd, "CONF" + str(conf.id), "NMR"))
            )
        for atom in conf.shieldings.keys():
            sigma = sum(
                [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
            ) / len(chemeq[atom])
            averaged[atom] = conf.bm_weight * sigma + averaged.get(atom, 0.0)
    # get SD on shieldings based on SD Gsolv
    if solv is not None:
        get_std_dev = (
            lambda conf: conf.lowlevel_gsolv_compare_info["std_dev"]
            if (conf.lowlevel_gsolv_compare_info["std_dev"] is not None)
            else 0.0
        )
        for _ in range(1000):
            for conf in calculate:
                conf.calc_free_energy(
                    e=energy,
                    solv=solv,
                    rrho=rrho,
                    t=config.temperature,
                    consider_sym=config.consider_sym,
                )
                conf.free_energy += normalvariate(0.0, get_std_dev(conf))
            calculate = calc_boltzmannweights(
                calculate, "free_energy", config.temperature
            )
            tmp_sigma = {}
            for i in range(1, config.nat + 1):
                tmp_sigma[i] = 0
            for conf in calculate:
                for atom in conf.shieldings.keys():
                    sigma = sum(
                        [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
                    ) / len(chemeq[atom])
                    tmp_sigma[atom] += conf.bm_weight * sigma
            for atom in conf.shieldings.keys():
                sigma_std_dev[atom].append(tmp_sigma[atom])
    # SD with 0.25 kcal/mol
    wanted = True
    if wanted:
        for _ in range(1000):
            for conf in calculate:
                conf.calc_free_energy(
                    e=energy,
                    solv=solv,
                    rrho=rrho,
                    t=config.temperature,
                    consider_sym=config.consider_sym,
                )
                conf.free_energy += normalvariate(0.0, (0.4 / AU2KCAL))
            calculate = calc_boltzmannweights(
                calculate, "free_energy", config.temperature
            )
            tmp_sigma = {}
            for i in range(1, config.nat + 1):
                tmp_sigma[i] = 0
            for conf in calculate:
                for atom in conf.shieldings.keys():
                    sigma = sum(
                        [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
                    ) / len(chemeq[atom])
                    tmp_sigma[atom] += conf.bm_weight * sigma
            for atom in conf.shieldings.keys():
                sigma_std_dev_const[atom].append(tmp_sigma[atom])

    with open(os.path.join(config.cwd, "averaged_shift.dat"), "w", newline=None) as out:
        line = "# in coord  element  σ(sigma)  SD(σ based on SD Gsolv)  SD(σ by 0.4 kcal/mol)       shift        σ_ref"
        print(line)
        out.write(line + "\n")
        line = "".ljust(int(105), "-")
        print(line)
        out.write(line + "\n")
        maxsigma = (
            max([len(str(sigma).split(".")[0]) for sigma in averaged.values()]) + 5
        )
        make_shift = (
            lambda atom: f"{-sigma+element_ref_shield.get(element[atom], 0.0):> {maxsigma}.2f}"
            if (element_ref_shield.get(element[atom], None) is not None)
            else "None"
        )
        for atom, sigma in averaged.items():
            try:
                std_dev = calc_std_dev(sigma_std_dev[atom])
            except Exception:
                std_dev = 0.0
            try:
                std_dev_const = calc_std_dev(sigma_std_dev_const[atom])
            except Exception:
                std_dev_const = 0.0
            try:
                line = (
                    f"{atom:< {10}}  {element[atom]:^{7}}  {sigma:> {maxsigma}.2f}  "
                    f"{std_dev:^ 24.6f} {std_dev_const:^ 24.6f} {make_shift(atom):>5}    {float(element_ref_shield.get(element[atom], 0.0)):> 10.3f}"
                )
                print(line)
                out.write(line + "\n")
            except Exception:
                line = f"{atom:< {10}}  {element[atom]:^{7}}  {sigma:> {maxsigma}.2f}"
                print(line)
                out.write(line + "\n")
        line = "".ljust(int(105), "-")
        print(line)
        out.write(line + "\n")

    ############################################################################
    # print min and max shielding within all conformers with averaging, but no boltzmann weighting
    atom_sigma = {}
    for atom in conf.shieldings.keys():
        atom_sigma[atom] = {}
        for conf in calculate:
            # get shielding constants
            atom_sigma[atom][conf.id] = sum(
                [conf.shieldings.get(eq_atom, 0.0) for eq_atom in chemeq[atom]]
            ) / len(chemeq[atom])
    tmppl = maxsigma + 1
    if tmppl <= 8:
        tmppl = 8
    line = f"\n{'# in coord':<{10}}  {'element':^{7}}  {'σ(sigma)':>{tmppl}} {'min(σ)*':>{tmppl}} CONFX  {'max(σ)*':>{tmppl}} CONFX  Δ(max-min)"
    print(line)
    line = "".ljust(int(105), "-")
    print(line)
    for atom in conf.shieldings.keys():
        try:
            minx = min(list(atom_sigma[atom].values()))
            minid = next(
                key for key, value in atom_sigma[atom].items() if value == minx
            )
            maxx = max(list(atom_sigma[atom].values()))
            maxid = next(
                key for key, value in atom_sigma[atom].items() if value == maxx
            )
            line = (
                f"{atom:< {10}}  {element[atom]:^{7}}  {averaged[atom]:> {maxsigma}.2f}  "
                + f"{minx :> {maxsigma}.2f} {'CONF'+str(minid):<{max([len(str(conf.id)) for conf in calculate])+5}}  {maxx :> {maxsigma}.2f} "
                + f"{'CONF'+str(maxid):<{max([len(str(conf.id)) for conf in calculate])+5}}  {maxx-minx:> {maxsigma}.2f}"
            )
            print(line)
        except Exception:
            pass
    line = "".ljust(int(105), "-")
    print(line)
    print(
        f"* min(σ) and max(σ) are averaged over the chemical equivalent atoms, but not Boltzmann weighted."
    )


def write_anmrrc(config):
    """ Write file .anmrrc with information processed by ANMR """

    # get absolute shielding constant of reference
    ref_decision = {
        "h": {
            "atomic_number": 1,
            "sigma": 0.0,
            "tm": "h_tm_shieldings",
            "orca": "h_orca_shieldings",
            "adf": "h_adf_shieldings",
            "ref_mol": getattr(config, "h_ref", "TMS"),
            "active": getattr(config, "h_active", False),
        },
        "c": {
            "atomic_number": 6,
            "sigma": 0.0,
            "tm": "c_tm_shieldings",
            "orca": "c_orca_shieldings",
            "adf": "c_adf_shieldings",
            "ref_mol": getattr(config, "c_ref", "TMS"),
            "active": getattr(config, "c_active", False),
        },
        "f": {
            "atomic_number": 9,
            "sigma": 0.0,
            "tm": "f_tm_shieldings",
            "orca": "f_orca_shieldings",
            "adf": "f_adf_shieldings",
            "ref_mol": getattr(config, "f_ref", "CFCl3"),
            "active": getattr(config, "f_active", False),
        },
        "si": {
            "atomic_number": 14,
            "sigma": 0.0,
            "tm": "si_tm_shieldings",
            "orca": "si_orca_shieldings",
            "adf": "si_adf_shieldings",
            "ref_mol": getattr(config, "si_ref", "TMS"),
            "active": getattr(config, "si_active", False),
        },
        "p": {
            "atomic_number": 15,
            "sigma": 0.0,
            "tm": "p_tm_shieldings",
            "orca": "p_orca_shieldings",
            "adf": "p_adf_shieldings",
            "ref_mol": getattr(config, "p_ref", "TMP"),
            "active": getattr(config, "p_active", False),
        },
    }
    # if non are active set all active
    if all(
        [
            not getattr(config, active)
            for active in ("h_active", "c_active", "f_active", "si_active", "p_active")
        ]
    ):
        for element in ref_decision.keys():
            ref_decision[element]["active"] = True

    refwarnings = []

    if config.solvent != "gas":
        # optimization in solvent:
        if config.prog == "tm" and config.sm2 != "dcosmors":
            refwarnings.append(
                f"{'WARNING:':{WARNLEN}}The geometry optimization of the reference molecule "
                "was calculated with DCOSMO-RS (sm2)!"
            )
        elif config.prog == "orca" and config.sm2 != "smd":
            refwarnings.append(
                f"{'WARNING:':{WARNLEN}}The geometry optimization of the reference molecule "
                "was calculated with SMD (sm2)!"
            )
        if config.prog == "tm":
            refsm2 = "DCOSMO-RS"
        elif config.prog == "orca":
            refsm2 = "SMD"
        if config.prog4_s == "tm":
            refsm4 = "DCOSMO-RS"
            refbasisS = "def2-TZVP"
            if config.sm4_s != "dcosmors":
                refwarnings.append(
                    f"{'WARNING:':{WARNLEN}}The reference shielding constant was calculated with "
                    "DCOSMORS (sm4_s)!"
                )
        elif config.prog4_s == "orca":
            refsm4 = "SMD"
            refbasisS = "def2-TZVP"
            if config.sm4_s != "smd":
                refwarnings.append(
                    f"{'WARNING:':{WARNLEN}}The reference shielding constant was calculated with "
                    "SMD (sm4_s)!"
                )
    else:
        refsm2 = ""
        refsm4 = ""
        refbasisS = "def2-TZVP"
    if config.basis_s != "def2-TZVP":
        refwarnings.append(
            f"{'WARNING:':{WARNLEN}}The reference shielding constant was calculated with the "
            f"basis def2-TZVP (basisS) instead of {config.basis_s}!"
        )

    if refwarnings:
        print(
            f"{'INFORMATION:':{WARNLEN}}The reference molecule shielding "
            + f"constant has been calucated with different settings."
        )
        print(
            f"{'':{WARNLEN}}You can always adjust the reference in the file .anmrrc manually!"
        )
        for line in refwarnings:
            print(line)

    # read NMR_references
    nmr_ref_user_path = os.path.expanduser(
        os.path.join("~/.censo_assets/", "censo_nmr_ref.json")
    )
    if os.path.isfile(nmr_ref_user_path):
        try:
            with open(nmr_ref_user_path, "r", encoding=CODING, newline=None) as inp:
                tmp_ref = json.load(inp)
        except (ValueError, TypeError, FileNotFoundError):
            print(
                f"{'ERROR:':{WARNLEN}}Your censo_nmr_ref.json file in {nmr_ref_user_path} is corrupted!\n"
            )
            tmp_ref = {}
    nmrref = NmrRef().dict_to_NMRRef(tmp_ref)
    # end reading NMR_references

    relay_names_func_s = {
        "r2scan-3c": "r2scan-3c",
        "pbeh-3c": "pbeh-3c",
        "b97-3c": "b97-3c",
        "tpss-d3": "tpss",
        "tpss-d4": "tpss",
        "tpss-novdw": "tpss",
        "tpss-d3(0)": "tpss",
        "kt2-novdw": "kt2",
        "pbe0-novdw": "pbe0",
        "pbe0-d3": "pbe0",
        "pbe0-d3(0)": "pbe0",
        "pbe0-d4": "pbe0",
        "wb97x-d3": "wb97x",
        "dsd-blyp-d3": "dsd-blyp",
    }
    tmp_func_s = relay_names_func_s.get(config.func_s, config.func_s)
    relay_names_func = {
        "tpss-d3": "tpss",
        "r2scan-3c": "r2scan-3c",
        "pbeh-3c": "pbeh-3c",
        "b97-3c": "b97-3c",
    }
    tmp_func = relay_names_func.get(config.func, config.func)

    for element, value in ref_decision.items():
        if value.get("active", False):
            # if getattr(nmrref, ref_decision[element].get(config.prog4_s))[
            #             ref_decision[element]["ref_mol"]].get(tmp_func, "not_calc")
            #             == "not_calc":
            try:
                ref_decision[element]["sigma"] = "{:4.3f}".format(
                    getattr(nmrref, ref_decision[element].get(config.prog4_s))[
                        ref_decision[element]["ref_mol"]
                    ][tmp_func][tmp_func_s][config.basis_s][config.solvent]
                )
            except KeyError as e:
                try:
                    ref_decision[element]["sigma"] = "{:4.3f}".format(
                        getattr(nmrref, ref_decision[element].get(config.prog4_s))[
                            ref_decision[element]["ref_mol"]
                        ][tmp_func].get("pbe0")["def2-TZVP"][config.solvent]
                    )
                    print(
                        f"{'WARNING:':{WARNLEN}}The reference absolute shielding constant "
                        f"for {config.func_s}/{config.basis_s} and element {element:3} could "
                        f"not be found, using {'pbe0/def2-TZVP'} reference instead!"
                    )
                    print(f"{'INFORMATION:':{WARNLEN}}The KeyError is: {e}")
                except KeyError as e:
                    print(
                        f"{'ERROR:':{WARNLEN}}The reference absolute shielding constant for "
                        f"element {element} could not be found!\n"
                        f"{'':{WARNLEN}}You have to edit the file .anmrrc by hand!"
                    )
                    print(f"{'INFORMATION:':{WARNLEN}}The KeyError is: {e}")
                    ref_decision[element]["sigma"] = f"{0.0 :4.3f}"

    # for elementactive
    exch = {True: 1, False: 0}
    exchonoff = {True: "on", False: "off"}
    # write .anmrrc
    with open(os.path.join(config.cwd, ".anmrrc"), "w", newline=None) as arc:
        arc.write("7 8 XH acid atoms\n")
        if config.resonance_frequency is not None:
            arc.write(
                "ENSO qm= {} mf= {} lw= 1.0  J= {} S= {} T= {:6.2f} \n".format(
                    str(config.prog4_s).upper(),
                    str(config.resonance_frequency),
                    exchonoff[config.couplings],
                    exchonoff[config.shieldings],
                    float(config.temperature),
                )
            )
        else:
            arc.write("ENSO qm= {} lw= 1.2\n".format(str(config.prog4_s).upper()))
        arc.write(
            "{}[{}] {}[{}]/{}//{}[{}]/{}\n".format(
                config.h_ref,
                config.solvent,
                config.func_s,
                refsm4,
                refbasisS,
                config.func,
                refsm2,
                config.basis,
            )
        )
        for element, value in ref_decision.items():
            if value.get("active", False):
                arc.write(
                    f"{value.get('atomic_number'):3}  "
                    f"{ref_decision[element]['sigma']}    {0.0}     "
                    f"{exch[ref_decision[element]['active']]}\n"
                )
    refs = {}
    for key in ref_decision:
        refs[key] = float(ref_decision[key]["sigma"])
    return refs


def part4(config, conformers, store_confs, ensembledata):
    """
    Calculate nmr properties: shielding and coupling constants on the populated
    conformers (either directly from part2 OPTIMIZATION or after REFINEMENT
    (part3))
    """
    save_errors = []
    if config.progress:
        print("#>>># CENSO: Starting part4", file=sys.stderr)
    print("\n" + "".ljust(PLENGTH, "-"))
    print("NMR MODE - PART4".center(PLENGTH, " "))
    print("".ljust(PLENGTH, "-") + "\n")
    # print flags for part4
    info = []
    info.append(["couplings", "calculate coupling constants"])
    if config.couplings:
        info.append(["prog4_j", "prog4J - program for coupling constant calculation"])
        info.append(["func_j", "funcJ  - functional for coupling constant calculation"])
        info.append(["basis_j", "basisJ - basis for coupling constant calculation"])
        if config.solvent != "gas":
            info.append(["sm4_j", "sm4J - solvent model for the coupling calculation"])
    info.append(["justprint", ""])
    info.append(["shieldings", "calculate shielding constants σ"])
    if config.shieldings:
        info.append(["prog4_s", "prog4S - program for shielding constant calculation"])
        info.append(["func_s", "funcS - functional for shielding constant calculation"])
        info.append(["basis_s", "basisS - basis for shielding constant calculation"])
        if config.solvent != "gas":
            info.append(["sm4_s", "sm4S - solvent model for the shielding calculation"])
    info.append(["justprint", ""])
    if getattr(config, "h_active"):
        info.append(["h_active", "Calculating proton spectrum"])
        info.append(["h_ref", "reference for 1H"])
    if getattr(config, "c_active"):
        info.append(["c_active", "Calculating carbon spectrum"])
        info.append(["c_ref", "reference for 13C"])
    if getattr(config, "f_active"):
        info.append(["f_active", "Calculating fluorine spectrum"])
        info.append(["f_ref", "reference for 19F"])
    if getattr(config, "si_active"):
        info.append(["si_active", "Calculating silicon spectrum"])
        info.append(["si_ref", "reference for 29Si"])
    if getattr(config, "p_active"):
        info.append(["p_active", "Calculating phosphorus spectrum"])
        info.append(["p_ref", "reference for 31P"])
    if all(
        [
            not getattr(config, active)
            for active in ("h_active", "c_active", "f_active", "si_active", "p_active")
        ]
    ):
        info.append(
            ["printoption", "Calculating spectrum for all nuclei", "H, C, F, Si, P"]
        )
    info.append(["resonance_frequency", "spectrometer frequency"])
    # active nuclei

    max_len_digilen = 0
    for item in info:
        if item[0] == "justprint":
            if "short-notation" in item[1]:
                tmp = len(item[1]) - len("short-notation:")
            else:
                tmp = len(item[1])
        else:
            tmp = len(item[1])
        if tmp > max_len_digilen:
            max_len_digilen = tmp
    max_len_digilen += 1
    if max_len_digilen < DIGILEN:
        max_len_digilen = DIGILEN

    optionsexchange = {True: "on", False: "off"}
    for item in info:
        if item[0] == "justprint":
            print(item[1:][0])
        else:
            if item[0] == "printoption":
                option = item[2]
            else:
                option = getattr(config, item[0])
            if option is True or option is False:
                option = optionsexchange[option]
            elif isinstance(option, list):
                option = [str(i) for i in option]
                if len(str(option)) > 40:
                    length = 0
                    reduced = []
                    for i in option:
                        length += len(i) + 2
                        if length < 40:
                            reduced.append(i)
                    reduced.append("...")
                    option = reduced
                    length = 0
                option = ", ".join(option)
            print(
                "{}: {:{digits}} {}".format(
                    item[1], "", option, digits=max_len_digilen - len(item[1])
                )
            )
    print("")
    # end print

    calculate = []  # has to be calculated in this run
    prev_calculated = []  # was already calculated in a previous run
    try:
        store_confs
    except NameError:
        store_confs = []  # stores all confs which are sorted out!

    # setup queues
    q = Queue()
    resultq = Queue()

    unoptimized_warning = False
    # sort conformers:
    for conf in list(conformers):
        if conf.removed:
            store_confs.append(conformers.pop(conformers.index(conf)))
            print(f"CONF{conf.id} is removed as requested by the user!")
            continue
        if (
            conf.part_info["part2"] != "passed"
            and conf.optimization_info["info"] != "calculated"
        ):
            unoptimized_warning = True
        if config.part3:
            # calc Boltzmann weights from part3
            energy = "highlevel_sp_info"
            rrho = "highlevel_grrho_info"
            gsolv = "highlevel_gsolv_info"
            boltzmannthr = config.part3_threshold
        elif config.part2:
            # part3 is not calculated use Boltzmann weights directly from part2
            energy = "lowlevel_sp_info"
            rrho = "lowlevel_grrho_info"
            gsolv = "lowlevel_gsolv_info"
            boltzmannthr = config.part2_P_threshold
        elif config.part1:
            # part2 is not calculated use Boltzmann weights directly from part1
            # --> misappropriate config.part2_P_threshold
            # This means starting from not DFT optimized geometries!
            energy = "prescreening_sp_info"
            rrho = "prescreening_grrho_info"
            gsolv = "prescreening_gsolv_info"
            boltzmannthr = config.part2_P_threshold
        else:
            print("UNEXPECTED BEHAVIOUR")

        mol = conformers.pop(conformers.index(conf))
        if getattr(conf, energy)["info"] != "calculated":
            store_confs.append(mol)
            continue
        elif getattr(conf, rrho)["info"] != "calculated" and config.evaluate_rrho:
            store_confs.append(mol)
            continue
        elif getattr(conf, gsolv)["info"] != "calculated" and config.solvent != "gas":
            store_confs.append(mol)
            continue
        else:
            calculate.append(mol)

    if unoptimized_warning:
        print_errors(
            f"{'INFORMATION:':{WARNLEN}}Conformers have not been optimized at DFT level!!!\n"
            f"{'':{WARNLEN}}Use results with care!\n",
            save_errors,
        )
    # SI geometry:
    if unoptimized_warning:
        ensembledata.si["part4"]["Geometry"] = "GFNn-xTB (input geometry)"
    else:
        ensembledata.si["part4"]["Geometry"], _ = config.get_method_name(
            "xtbopt",
            func=config.func,
            basis=config.basis,
            solvent=config.solvent,
            sm=config.sm2,
        )
        ensembledata.si["part4"]["Geometry"] += f" @optlevel: {config.optlevel2}"
    #
    if not calculate and not prev_calculated:
        print(f"{'ERROR:':{WARNLEN}}No conformers left!")
        print("Going to exit!")
        sys.exit(1)

    calculate.sort(key=lambda x: int(x.id))
    print(f"Considering the following {len(calculate)} conformers:")
    print_block(["CONF" + str(i.id) for i in calculate])

    # Calculate Boltzmann weight for confs:
    if config.part3:
        using_part = "part3 - refinement"
        if not config.evaluate_rrho:
            rrho = None
            rrho_method = None
        else:
            rrho_method, _ = config.get_method_name(
                "rrhoxtb",
                bhess=config.bhess,
                gfn_version=config.part3_gfnv,
                sm=config.sm_rrho,
                solvent=config.solvent,
            )
        if config.solvent == "gas":
            gsolv = None
            energy_method, solv_method = config.get_method_name(
                "xtbopt",
                func=config.func3,
                basis=config.basis3,
                sm=config.smgsolv3,
                gfn_version=config.part3_gfnv,
                solvent=config.solvent,
            )
        else:
            if config.smgsolv3 in ("cosmors", "cosmors-fine"):
                tmp_name = "cosmors"
            elif config.smgsolv3 in ("alpb_gsolv", "gbsa_gsolv", "smd_gsolv"):
                tmp_name = config.smgsolv3
            else:
                tmp_name = "sp_implicit"
            energy_method, solv_method = config.get_method_name(
                tmp_name,
                func=config.func3,
                basis=config.basis3,
                sm=config.smgsolv3,
                gfn_version=config.part3_gfnv,
                solvent=config.solvent,
            )
    elif config.part2:
        using_part = "part2 - optimization"
        if not config.evaluate_rrho:
            rrho = None
            rrho_method = None
        else:
            rrho_method, _ = config.get_method_name(
                "rrhoxtb",
                bhess=config.bhess,
                gfn_version=config.part2_gfnv,
                sm=config.sm_rrho,
                solvent=config.solvent,
            )
        if config.solvent == "gas":
            gsolv = None
            energy_method, solv_method = config.get_method_name(
                "xtbopt",
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv2,
                gfn_version=config.part2_gfnv,
                solvent=config.solvent,
            )
        else:
            if config.smgsolv2 in ("cosmors", "cosmors-fine"):
                tmp_name = "cosmors"
            elif config.smgsolv2 in ("alpb_gsolv", "gbsa_gsolv", "smd_gsolv"):
                tmp_name = config.smgsolv2
            else:
                tmp_name = "sp_implicit"
            energy_method, solv_method = config.get_method_name(
                tmp_name,
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv2,
                gfn_version=config.part2_gfnv,
                solvent=config.solvent,
            )
    elif config.part1:
        using_part = "part1 - prescreening"
        # on DFT unoptimized geometries!
        if not config.evaluate_rrho:
            rrho = None
            rrho_method = None
        else:
            rrho_method, _ = config.get_method_name(
                "rrhoxtb",
                bhess=config.bhess,
                gfn_version=config.part1_gfnv,
                sm=config.sm_rrho,
                solvent=config.solvent,
            )
        if config.solvent == "gas":
            gsolv = None
            energy_method, solv_method = config.get_method_name(
                "xtbopt",
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv1,
                gfn_version=config.part1_gfnv,
                solvent=config.solvent,
            )
        else:
            if config.smgsolv1 in ("cosmors", "cosmors-fine"):
                tmp_name = "cosmors"
            elif config.smgsolv2 in ("alpb_gsolv", "gbsa_gsolv", "smd_gsolv"):
                tmp_name = config.smgsolv1
            else:
                tmp_name = "sp_implicit"
            energy_method, solv_method = config.get_method_name(
                tmp_name,
                func=config.func,
                basis=config.basis,
                sm=config.smgsolv1,
                gfn_version=config.part1_gfnv,
                solvent=config.solvent,
            )
    # SI information:-------------------------------------------------------
    ensembledata.si["part4"]["Energy"] = f"using Energy from {using_part}"
    ensembledata.si["part4"]["Energy_settings"] = f"see {using_part}"
    ensembledata.si["part4"]["G_mRRHO"] = f"using G_mRRHO from {using_part}"
    ensembledata.si["part4"]["G_solv"] = f"using G_solv from {using_part}"
    ensembledata.si["part4"]["Threshold"] = f"Boltzmann sum threshold: {boltzmannthr} %"
    if config.prog4_j == config.prog4_s:
        ensembledata.si["part4"]["main QM code"] = str(config.prog4_j).upper()
    else:
        ensembledata.si["part4"]["main QM code"] = (
            str(config.prog4_j).upper() + " " + str(config.prog4_s).upper()
        )
    # END SI information--------------------------------------------------------

    for conf in calculate:
        conf.calc_free_energy(
            e=energy,
            solv=gsolv,
            rrho=rrho,
            t=config.temperature,
            consider_sym=config.consider_sym,
        )
    calculate = calc_boltzmannweights(calculate, "free_energy", config.temperature)
    try:
        minfree = min([i.free_energy for i in calculate if i is not None])
    except ValueError:
        raise
    for conf in calculate:
        conf.rel_free_energy = (conf.free_energy - minfree) * AU2KCAL
    calculate.sort(key=lambda x: int(x.id))

    # printout for part4 -------------------------------------------------------
    print("\n" + "".ljust(int(PLENGTH / 2), "-"))
    print("* Gibbs free energies used in part4 *".center(int(PLENGTH / 2), " "))
    print("".ljust(int(PLENGTH / 2), "-") + "\n")
    columncall = [
        lambda conf: "CONF" + str(getattr(conf, "id")),
        lambda conf: getattr(conf, energy)["energy"],
        # lambda conf: getattr(conf, gsolv)["energy"],
        lambda conf: getattr(conf, gsolv)
        .get("range", {})
        .get(config.temperature, getattr(conf, gsolv, {"energy": 0.0})["energy"]),
        # lambda conf: getattr(conf, rrho)["energy"],
        lambda conf: conf.get_mrrho(config.temperature, rrho, config.consider_sym),
        lambda conf: getattr(conf, "free_energy"),
        lambda conf: getattr(conf, "rel_free_energy"),
        lambda conf: getattr(conf, "bm_weight") * 100,
    ]
    columnheader = [
        "CONF#",
        "E [Eh]",
        "Gsolv [Eh]",
        "GmRRHO [Eh]",
        "Gtot",
        "ΔGtot",
        "Boltzmannweight",
    ]
    columndescription = [
        "",
        "",
        "",
        "",
        "[Eh]",
        "[kcal/mol]",
        f"  % at {config.temperature:.2f} K",
    ]
    columnformat = ["", (12, 7), (12, 7), (12, 7), (12, 7), (5, 2), (5, 2)]
    columndescription[1] = energy_method
    columndescription[2] = solv_method
    columndescription[3] = rrho_method
    if not config.evaluate_rrho or config.solvent == "gas":
        if not config.evaluate_rrho:
            # ignore rrho in printout
            columncall.pop(3)
            columnheader.pop(3)
            columndescription.pop(3)
            columnformat.pop(3)
        if config.solvent == "gas":
            columncall.pop(2)
            columnheader.pop(2)
            columndescription.pop(2)
            columnformat.pop(2)

    printout(
        os.path.join(config.cwd, "part4.dat"),
        columncall,
        columnheader,
        columndescription,
        columnformat,
        calculate,
        minfree,
    )
    calculate.sort(reverse=True, key=lambda x: float(x.bm_weight))
    sumup = 0.0
    for conf in list(calculate):
        sumup += conf.bm_weight
        if sumup >= boltzmannthr:
            if conf.bm_weight < (1 - boltzmannthr):
                store_confs.append(calculate.pop(calculate.index(conf)))
    print(f"\nConformers that are below the Boltzmann-thr of {boltzmannthr}:")
    ensembledata.nconfs_per_part["part4"] = len(calculate)
    print_block(["CONF" + str(i.id) for i in calculate])

    # create NMR folder
    folder = "NMR"
    save_errors, store_confs, calculate = new_folders(
        config.cwd, calculate, folder, save_errors, store_confs
    )
    # need to copy optimized coord to folder
    if config.part3 and config.part2 or config.part2:
        # need to copy optimized coord to folder
        for conf in list(calculate):
            tmp1 = os.path.join(config.cwd, "CONF" + str(conf.id), config.func, "coord")
            tmp2 = os.path.join("CONF" + str(conf.id), folder, "coord")
            try:
                shutil.copy(tmp1, tmp2)
            except FileNotFoundError:
                print(f"{'ERROR:':{WARNLEN}}can't copy optimized geometry!")
                store_confs.append(calculate.pop(calculate.index(conf)))
    elif config.part3:
        # structures can be DFT optimized or not (part2 might not have been run)
        for conf in list(calculate):
            tmp1 = os.path.join(config.cwd, "CONF" + str(conf.id), "part3", "coord")
            tmp2 = os.path.join("CONF" + str(conf.id), folder, "coord")
            try:
                shutil.copy(tmp1, tmp2)
            except FileNotFoundError:
                print(f"{'ERROR:':{WARNLEN}}can't copy geometry!")
                store_confs.append(calculate.pop(calculate.index(conf)))
    elif config.part1:
        # do not use coord from folder config.func it could be optimized if
        # part2 has ever been run, take coord from ensemble file
        # write coord to folder
        calculate, store_confs, save_errors = ensemble2coord(
            config, folder, calculate, store_confs, save_errors
        )
    if config.couplings:
        print("\nPerforming coupling constant calculations:")
        # check if J calculated before!
        for conf in list(calculate):
            if getattr(conf, "nmr_coupling_info")["info"] == "calculated":
                prev_calculated.append(calculate.pop(calculate.index(conf)))
            elif getattr(conf, "nmr_coupling_info")["info"] == "failed":
                print(
                    f"{'INFORMATION:':{WARNLEN}}The calculation failed for CONF{conf.id} in the previous run."
                )
                store_confs.append(calculate.pop(calculate.index(conf)))
            else:
                # still in calculate
                pass

        if not calculate + prev_calculated:
            print(f"{'ERROR:':{WARNLEN}}No conformers left!")
            print("Going to exit!")
            sys.exit(1)

        instruction_j = {
            "jobtype": "couplings_sp",
            "prepinfo": ["high+"],
            "func": config.func_j,
            "basis": config.basis_j,
            "charge": config.charge,
            "unpaired": config.unpaired,
            "solvent": config.solvent,
            "sm": config.sm4_j,
            "success": False,
            # nmractive nuclei
            "h_active": config.h_active,
            "c_active": config.c_active,
            "f_active": config.f_active,
            "p_active": config.p_active,
            "si_active": config.si_active,
            "onlyread": config.onlyread,
        }
        if config.prog4_j == "orca":
            job = OrcaJob
            instruction_j["prepinfo"].extend(["nmrJ"])
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )
        elif config.prog4_j == "tm":
            job = TmJob
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )
            # escf no mgrid!!!!
        elif config.prog4_j == "adf":
            instruction_j["method"], _ = config.get_method_name(
                instruction_j["jobtype"],
                func=instruction_j["func"],
                basis=instruction_j["basis"],
                sm=instruction_j["sm"],
                solvent=instruction_j["solvent"],
                prog=config.prog4_j,
            )

        check = {True: "was successful", False: "FAILED"}
        pl = config.lenconfx + 4 + len(str("/" + folder))
        if calculate:
            calculate = run_in_parallel(
                config,
                q,
                resultq,
                job,
                config.maxthreads,
                config.omp,
                calculate,
                instruction_j,
                config.balance,
                folder,
            )
            for conf in list(calculate):
                line = (
                    f"Coupling constant calculation {check[conf.job['success']]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}"
                )
                print(line)
                if not conf.job["success"]:
                    save_errors.append(line)
                    conf.nmr_coupling_info["info"] = "failed"
                    conf.nmr_coupling_info["method"] = instruction_j["method"]
                    conf.nmr_coupling_info["h_active"] = instruction_j["h_active"]
                    conf.nmr_coupling_info["c_active"] = instruction_j["c_active"]
                    conf.nmr_coupling_info["f_active"] = instruction_j["f_active"]
                    conf.nmr_coupling_info["si_active"] = instruction_j["si_active"]
                    conf.nmr_coupling_info["p_active"] = instruction_j["p_active"]
                    conf.part_info["part4"] = "refused"
                    store_confs.append(calculate.pop(calculate.index(conf)))
                else:
                    conf.nmr_coupling_info["info"] = "calculated"
                    conf.nmr_coupling_info["method"] = instruction_j["method"]
                    conf.nmr_coupling_info["h_active"] = instruction_j["h_active"]
                    conf.nmr_coupling_info["c_active"] = instruction_j["c_active"]
                    conf.nmr_coupling_info["f_active"] = instruction_j["f_active"]
                    conf.nmr_coupling_info["si_active"] = instruction_j["si_active"]
                    conf.nmr_coupling_info["p_active"] = instruction_j["p_active"]
            # save current data to jsonfile
            config.write_json(
                config.cwd,
                [i.provide_runinfo() for i in calculate]
                + [i.provide_runinfo() for i in prev_calculated]
                + [i.provide_runinfo() for i in store_confs]
                + [ensembledata],
                config.provide_runinfo(),
            )

        if prev_calculated:
            for conf in list(prev_calculated):
                conf.job["workdir"] = os.path.normpath(
                    os.path.join(config.cwd, "CONF" + str(conf.id), folder)
                )
                line = (
                    f"Coupling constant calculation {check[True]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}"
                )
                print(line)
                calculate.append(prev_calculated.pop(prev_calculated.index(conf)))

        for conf in calculate:
            conf.reset_job_info()
        if not calculate:
            print(f"{'ERROR:':{WARNLEN}}No conformers left!")
            print("Going to exit!")
            sys.exit(1)

    if config.shieldings:
        print("\nPerforming shielding constant calculations:")
        # start shielding constants
        # check if S calculated before!
        for conf in list(calculate):
            if getattr(conf, "nmr_shielding_info")["info"] == "calculated":
                prev_calculated.append(calculate.pop(calculate.index(conf)))
            elif getattr(conf, "nmr_shielding_info")["info"] == "failed":
                store_confs.append(calculate.pop(calculate.index(conf)))
        for conf in calculate:
            conf.reset_job_info()
        if not calculate + prev_calculated:
            print(f"{'ERROR:':{WARNLEN}}No conformers left!")
            print("Going to exit!")
            sys.exit(1)

        instruction_s = {
            "jobtype": "shieldings_sp",
            "prepinfo": ["high+"],
            "func": config.func_s,
            "basis": config.basis_s,
            "charge": config.charge,
            "unpaired": config.unpaired,
            "solvent": config.solvent,
            "sm": config.sm4_s,
            "success": False,
            # nmractive nuclei
            "h_active": config.h_active,
            "c_active": config.c_active,
            "f_active": config.f_active,
            "p_active": config.p_active,
            "si_active": config.si_active,
            "onlyread": config.onlyread,
            "moread": None,
        }

        if config.basis_j != config.basis_s:
            # do a new calculation
            # cefine if turbomole
            instruction_s["prepinfo"] = ["high+"]
        if config.prog4_j != config.prog4_s:
            # do a new calculation
            # cefine if turbomole
            instruction_s["prepinfo"] = ["high+"]
        if (config.basis_j == config.basis_s) and (config.prog4_j == config.prog4_s):
            if config.func_j == config.func_s and config.couplings:
                # don't do single-point
                if config.prog4_s == "tm":
                    instruction_s["prepinfo"] = []
                instruction_s["jobtype"] = "shieldings"
                if config.prog4_s == "orca":
                    instruction_s["moread"] = ["! MORead", '%moinp "inpJ.gbw"']
            elif config.func_j != config.func_s and config.couplings:
                instruction_s["prepinfo"] = ["high+"]
                # use already converged mos as start mos
                if config.prog4_s == "tm":
                    instruction_s["copymos"] = "mos_j"
                instruction_s["jobtype"] = "shieldings_sp"

        if config.prog4_s == "orca":
            job = OrcaJob
            instruction_s["prepinfo"].extend(["nmrS"])
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_s,
            )
        elif config.prog4_s == "tm":
            job = TmJob
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_j,
            )
        elif config.prog4_s == "adf":
            instruction_s["method"], _ = config.get_method_name(
                instruction_s["jobtype"],
                func=instruction_s["func"],
                basis=instruction_s["basis"],
                sm=instruction_s["sm"],
                solvent=instruction_s["solvent"],
                prog=config.prog4_j,
            )
        check = {True: "was successful", False: "FAILED"}
        pl = config.lenconfx + 4 + len(str("/" + folder))
        if calculate:
            calculate = run_in_parallel(
                config,
                q,
                resultq,
                job,
                config.maxthreads,
                config.omp,
                calculate,
                instruction_s,
                config.balance,
                folder,
            )
            for conf in list(calculate):
                line = (
                    f"Shielding constant calculation {check[conf.job['success']]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}"
                )
                print(line)
                if not conf.job["success"]:
                    save_errors.append(line)
                    conf.nmr_shielding_info["info"] = "failed"
                    conf.nmr_shielding_info["method"] = instruction_s["method"]
                    conf.nmr_shielding_info["h_active"] = instruction_s["h_active"]
                    conf.nmr_shielding_info["c_active"] = instruction_s["c_active"]
                    conf.nmr_shielding_info["f_active"] = instruction_s["f_active"]
                    conf.nmr_shielding_info["si_active"] = instruction_s["si_active"]
                    conf.nmr_shielding_info["p_active"] = instruction_s["p_active"]
                    conf.part_info["part4"] = "refused"
                    store_confs.append(calculate.pop(calculate.index(conf)))
                else:
                    conf.nmr_shielding_info["info"] = "calculated"
                    conf.nmr_shielding_info["method"] = instruction_s["method"]
                    conf.nmr_shielding_info["h_active"] = instruction_s["h_active"]
                    conf.nmr_shielding_info["c_active"] = instruction_s["c_active"]
                    conf.nmr_shielding_info["f_active"] = instruction_s["f_active"]
                    conf.nmr_shielding_info["si_active"] = instruction_s["si_active"]
                    conf.nmr_shielding_info["p_active"] = instruction_s["p_active"]
            # save current data to jsonfile
            config.write_json(
                config.cwd,
                [i.provide_runinfo() for i in calculate]
                + [i.provide_runinfo() for i in prev_calculated]
                + [i.provide_runinfo() for i in store_confs]
                + [ensembledata],
                config.provide_runinfo(),
            )
        if prev_calculated:
            for conf in list(prev_calculated):
                conf.job["workdir"] = os.path.normpath(
                    os.path.join(config.cwd, "CONF" + str(conf.id), folder)
                )
                line = (
                    f"Shielding constant calculation {check[True]}"
                    f" for {last_folders(conf.job['workdir'], 2):>{pl}}"
                )
                print(line)
                calculate.append(prev_calculated.pop(prev_calculated.index(conf)))

    # SI update-----------------------------------------------------------------
    if config.couplings:
        ensembledata.si["part4"]["Coupling constants"] = instruction_j["method"]
        if config.prog4_j == "tm":
            ensembledata.si["part4"]["Coupling constants"] += " " + " ".join(
                qm_prepinfo["tm"][instruction_j["prepinfo"][0]]
            ).replace("-", "")
        elif config.prog4_j == "orca":
            ensembledata.si["part4"]["Coupling constants"] += " " + " ".join(
                qm_prepinfo["orca"][instruction_j["prepinfo"][0]]
            )
    else:
        ensembledata.si["part4"]["Coupling constants"] = "not calculated"
    if config.shieldings:
        ensembledata.si["part4"]["Shielding constants"] = instruction_s["method"]
        if config.prog4_s == "tm":
            if (
                config.prog4_j == "tm"
                and config.func_s == config.func_j
                and config.basis_s == config.basis_j
                and config.couplings
            ):
                ensembledata.si["part4"]["Shielding constants"] += " " + " ".join(
                    qm_prepinfo["tm"][instruction_j["prepinfo"][0]]
                ).replace("-", "")
            else:
                ensembledata.si["part4"]["Shielding constants"] += " " + " ".join(
                    qm_prepinfo["tm"][instruction_s["prepinfo"][0]]
                ).replace("-", "")
        elif config.prog4_s == "orca":
            ensembledata.si["part4"]["Shielding constants"] += " " + " ".join(
                qm_prepinfo["orca"][instruction_s["prepinfo"][0]]
            )
    else:
        ensembledata.si["part4"]["Shielding constants"] = "not calculated"
    # END SI update--------------------------------------------------------------

    if not calculate:
        print(f"{'ERROR:':{WARNLEN}}No conformers left!")
        print("Going to exit!")
        sys.exit(1)

    # write anmr_enso output!
    print("\nGenerating file anmr_enso for processing with the ANMR program.")
    for conf in calculate:
        conf.calc_free_energy(
            e=energy,
            solv=gsolv,
            rrho=rrho,
            t=config.temperature,
            consider_sym=config.consider_sym,
        )
    calculate = calc_boltzmannweights(calculate, "free_energy", config.temperature)
    try:
        length = max([len(str(i.id)) for i in calculate]) + 1
        if int(length) < 4:
            length = 4
        fmtenergy = max([len("{: .7f}".format(i.free_energy)) for i in calculate])
        if config.solvent != "gas":
            fmtsolv = max(
                [
                    len("{: .7f}".format(getattr(i, gsolv, {"energy": 0.0})["energy"]))
                    for i in calculate
                ]
            )
        else:
            fmtsolv = 10
        if config.evaluate_rrho:
            fmtrrho = max(
                [
                    len("{: .7f}".format(getattr(i, rrho, {"energy": 0.0})["energy"]))
                    for i in calculate
                ]
            )
        else:
            fmtrrho = 10
    except Exception as e:
        print(e)
        length = 6
        fmtenergy = 10
        fmtrrho = 10
        fmtsolv = 10
    with open(os.path.join(config.cwd, "anmr_enso"), "w", newline=None) as out:
        out.write(
            f"{'ONOFF':5} {'NMR':^{length}} {'CONF':^{length}} {'BW':7} "
            f"{'Energy':{fmtenergy}} {'Gsolv':{fmtsolv}} {'mRRHO':{fmtrrho}} {'gi':7}\n"
        )
        for conf in calculate:
            out.write(
                f"{1:<5} {conf.id:^{length}} {conf.id:^{length}} "
                f"{conf.bm_weight: {2}.4f} {getattr(conf, energy)['energy']: {fmtenergy}.{7}f} "
                f"{getattr(conf, str(gsolv), {'energy': 0.0})['energy']: {fmtsolv-7}.{7}f} "
                f"{conf.get_mrrho(config.temperature, rrho, config.consider_sym): {fmtrrho-7}.{7}f} "
                # f"{getattr(conf, str(rrho), {'energy': 0.0})['energy']: {fmtrrho-7}.{7}f} "
                f"{conf.gi:.3f}\n"
            )

    # write .anmrrc
    print("\nWriting .anmrrc!")
    element_ref_shield = write_anmrrc(config)

    if (config.prog4_s == config.prog4_j or
        config.couplings and not config.shieldings or
        config.shieldings and not config.couplings
        ):
        print("\nGenerating plain nmrprop.dat files for each populated conformer.")
        print("These files contain all calculated shielding and coupling constants.")
        print("The files can be read by ANMR using the keyword '-plain'.\n")
        # write generic:
        instructgeneric = {
            "jobtype": "genericout",
            "nat": int(config.nat),
            "onlyread": config.onlyread,
        }
        calculate = run_in_parallel(
            config,
            q,
            resultq,
            job,
            config.maxthreads,
            config.omp,
            calculate,
            instructgeneric,
            False,
            folder,
        )
    else:
        print(f"{'INFORMATION:':{WARNLEN}}Coupling and shielding constants have been generated by different"
              f"{':':{WARNLEN}}programs and the plain output nmrprop.dat has not been generated!")

    # printout the averaged shielding constants
    if config.shieldings:
        average_shieldings(config, calculate, element_ref_shield, energy, gsolv, rrho)

    # reset
    for conf in calculate:
        conf.reset_job_info()

    if save_errors:
        print("\n***---------------------------------------------------------***")
        print("Printing most relevant errors again, just for user convenience:")
        for _ in list(save_errors):
            print(save_errors.pop())
        print("***---------------------------------------------------------***")
    # end printout for part4
    tmp = int((PLENGTH - len("END of Part4")) / 2)
    print("\n" + "".ljust(tmp, ">") + "END of Part4" + "".rjust(tmp, "<"))
    if config.progress:
        print("#>>># CENSO: Finished part4", file=sys.stderr)
    return config, calculate, store_confs, ensembledata
